
/* Aruzhan Bissimbayeva  ADA-2403M  practice 1
lab3.cpp
Динамическая память и указатели. Параллельные вычисления с OpenMP.

В данной программе реализуется создание динамического массива целых чисел
с использованием указателей. Размер массива вводится пользователем с клавиатуры,
после чего массив заполняется случайными значениями в заданном диапазоне.

Для вычисления среднего арифметического элементов массива используется отдельная функция.
Подсчёт суммы элементов выполняется параллельно с применением технологии OpenMP
и директивы reduction, что обеспечивает корректное объединение результатов,
полученных в разных потоках.

Программа демонстрирует работу с динамической памятью (выделение и освобождение),
использование указателей, а также основы параллельных вычислений в C++.
   Пример запуска кода в терминале:
   g++ lab3.cpp -fopenmp -o lab3.exe 
   .\lab3.exe
*/

#include <iostream> // Подключение библиотеки для ввода и вывода данных (cout, cin)
#include <random>   // Подключение библиотеки для генерации случайных чисел
#include <chrono>   // Подключение библиотеки для работы со временем
#ifdef _OPENMP
#include <omp.h>    // подключаем OpenMP
#endif

using namespace std;    // Использование стандартного пространства имён std

// Функция для вычисления среднего (параллельно с OpenMP)
// arr — указатель на динамический массив
// N — количество элементов в массиве

double calculate_average(int* arr, size_t N) {
    long long sum = 0;          // используем long long, чтобы избежать переполнения при больших N
    #ifdef _OPENMP              // если программа скомпилирована с поддержкой OpenMP
    // Параллельный for с редукцией: каждый поток суммирует свою часть, затем происходит редукция
    #pragma omp parallel for reduction(+:sum)   // редукция гарантирует корректное сложение результатов
    for (int i = 0; i < static_cast<int>(N); ++i) {   // цикл проходит по всем элементам массива,  static_cast используется для приведения типа size_t к int
        sum += arr[i];                      // каждый поток добавляет свою часть данных
    }
    #else
    // Если OpenMP недоступен, выполняем обычный проход по массиву
    for (size_t i = 0; i < N; ++i) {         // последовательный обход массива
        sum += arr[i];                       // прибавление текущего элемента к сумме
    }
    #endif
    return static_cast<double>(sum) / N;        // преобразование суммы в double и вычисление среднего значения
}

int main() {
    constexpr int RAND_MIN_VAL = 1;      // минимальное значение случайных чисел
    constexpr int RAND_MAX_VAL = 1000;   // максимальное значение
    constexpr size_t PRINT_LIMIT = 100;  // ограничение на вывод (если массив большой - не печатаем)

    // Ввод размера массива N с клавиатуры
    cout << "Enter N (array size): ";        // запрос размера массива у пользователя
    size_t N;                                // переменная для хранения размера массива
    if (!(cin >> N) || N == 0) {             // проверка корректности ввода и того, что размер больше нуля
        cerr << "Invalid size\n";            // вывод сообщения об ошибке
        return 1;                            // завершение программы с кодом ошибки
    }

    //Создание динамического массива 
    int* arr = new int[N];              // динамическое выделение памяти под N элементов типа int
                                        // arr — указатель на первый элемент массива

    // Заполнение массива случайными числами 
    random_device rd;                   // источник энтропии для генератора случайных чисел
    mt19937 gen(rd());                  // инициализация генератора Mersenne Twister
    uniform_int_distribution<int> dist(RAND_MIN_VAL, RAND_MAX_VAL);  // определение равномерного распределения случайных чисел в заданном диапазоне
    for (size_t i = 0; i < N; ++i) {    // цикл заполнения массива
        arr[i] = dist(gen);             // генерация случайного числа и запись его в массив
    }

    // Печать массива, если он небольшой
    if (N <= PRINT_LIMIT) {
        cout << "Array: ";
        for (size_t i = 0; i < N; ++i) 
        cout << arr[i] << ' ';      // печать каждого элемента массива
        cout << '\n';               // переход на новую строку
    } else {                        // если массив большой, не выводим его полностью
        cout << "Array size " << N << " (not printed)\n";
    }

    // Вычисление среднего (запустится параллельно, если OpenMP включён)
    double avg = calculate_average(arr, N);     // вызов функции вычисления среднего значения массива

    // Вывод результата вычисления
    cout << "Среднее значение элементов массива = " << avg << '\n';

    // Проверка: была ли компиляция с поддержкой OpenMP
    #ifdef _OPENMP               // Если OpenMP доступен
    cout << "OpenMP threads (max) = " << omp_get_max_threads() << '\n';  // Вывод максимального количества потоков OpenMP
    #else                        // Если OpenMP не использовался при компиляции
    cout << "OpenMP not available (compiled without -fopenmp)\n";
    #endif

     //Освобождение динамической памяти
    delete[] arr;        // обязательно освобождаем массив

    return 0;           // Успешное завершение программы
}